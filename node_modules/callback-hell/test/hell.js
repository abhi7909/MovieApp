var rfr = require('rfr');
var h = rfr('hell');
var _ = require('underscore');
var assert = require('chai').assert;

describe("callback-hell", function() {
   it( "asyncSerial runs each async function in a consecutive manner and dumps the channel on completion", function() {
      var fns = [
         function(_r,cb) { cb( h.mkResult(h.mkWriteOrder('foo',1))); },
         function(re,cb) {
            if(re.get("foo") === 1)
               cb(h.mkNull());
            else
               cb(h.mkError("blah"));
         },
         function(re,cb) { cb( h.mkResult(h.mkWriteOrder('bar',2))); },
         function(re,cb) {
            if(re.get("foo") === 1 && re.get("bar") === 2)
               cb(h.mkNull());
            else
               cb(h.mkError("blah"));
         },
      ];
      h.asyncSerial(fns,function(w) {
         assert(h.isResult(w));
         assert('foo' in w.result);
         assert('bar' in w.result);
         assert( _.keys(w.result).length === 2 );
      });
   });

   it( "asyncSerial runs until an error-value. This is the thing that is passed to the final callback", function() {
      var touched = false;
      var fns = [
         function(_r,cb) { cb(h.mkError('blah')); },
         function(_r,cb) { touched = true; cb( h.mkResult(h.mkWriteOrder('foo',1))); }
      ];
      h.asyncSerial(fns, function(w) {
         assert(h.isError(w));
         assert(!touched); 
      });
   });

   it( "mapWrap works as expected", function() {
      var cb = function(w) { assert(w.result === true); };
      var mcb = h.mw(cb, function(_) { return true; });
      mcb( h.mkResult( false ));
   });

   it( "asyncParallel runs async functions dumps the channel on completion", function() {
      var range = _.range(0,30);
      var fns = _.chain(range)
         .map( function(x) { return function(cb) { cb(h.mkResult(h.mkWriteOrder(x,x))); }; } )
         .value();
      h.asyncParallel(fns, function(w) {
         assert(h.isResult(w));
         _.each(range, function(x) { assert( x === w.result[x] ); });
      });
   });

   it( "asyncParallel returns error value when a single function errors", function() {
      var range = _.range(0,30);
      var fns = _.chain(range)
         .map( function(x) { return function(cb) { cb( x === 0 ? h.mkError('') : h.mkResult(h.mkWriteOrder(x,x))); }; } )
         .value();
      h.asyncParallel(fns,function(w) {
         assert(h.isError(w));
      });
   });

   it( "mapArr works properly", function() {
      var range = _.range(0,5);
      var fn = function(x,cb) {
         h.rw(cb)( x * 2 );
      };
      h.asyncSerialArr( range, function(w) {
         _.each( w.result, function(x,i) {
            assert( x === i * 2 );
         });
      });
   });

   it( "mapObj works properly", function() {
      var range = _.range(0,2);
      range = _.object( _.zip( range, range )); 
      var fn = function(k,v,cb) {
         h.rw(cb)( k + v );
      };
      h.asyncParallelObj( range, function(w) {
         _.each( w.result, function(k,v) {
            assert( v === k * 2 );
         });
      });
   });
});

